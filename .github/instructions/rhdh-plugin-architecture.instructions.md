---
description: "Architecture standards for RHDH/Backstage custom dynamic plugins. Apply when designing, reviewing, or implementing custom plugins for Red Hat Developer Hub."
globs:
  - "**/plugins/**/*.ts"
  - "**/plugins/**/*.tsx"
  - "**/dynamic-plugins-config.yaml"
  - "**/app-config*.yaml"
  - "**/*.agent.md"
---

# RHDH Plugin Architecture Standards

## Plugin Structure

Every custom RHDH dynamic plugin follows this directory layout:

```
plugins/{plugin-name}/
├── package.json
├── tsconfig.json
├── src/
│   ├── plugin.ts              # Plugin registration + route/mountPoint exports
│   ├── index.ts               # Public API barrel export
│   ├── components/
│   │   ├── {PageName}.tsx     # Top-level page component
│   │   └── {Widget}.tsx       # Reusable sub-components
│   ├── hooks/
│   │   └── use{Feature}.ts    # Custom React hooks (data fetching, state)
│   └── api/
│       └── {apiName}.ts       # API client wrappers
├── dev/
│   └── index.tsx              # Dev harness for standalone testing
└── dist-dynamic/              # Generated by export-dynamic-plugin (do not edit)
```

## Naming Conventions

- Plugin package: `@internal/plugin-{name}` (e.g., `@internal/plugin-home-three-horizons`)
- Component files: PascalCase matching component name (e.g., `HeroBanner.tsx`)
- Hook files: camelCase prefixed with `use` (e.g., `useEntityCounts.ts`)
- API files: camelCase (e.g., `catalogStats.ts`)

## Plugin Registration (plugin.ts)

```typescript
import {
  createPlugin,
  createRoutableExtension,
} from '@backstage/core-plugin-api';

export const myPlugin = createPlugin({
  id: 'my-plugin-id',
  routes: {
    root: rootRouteRef,
  },
});

// For dynamicRoutes - export routable extension
export const MyPluginPage = myPlugin.provide(
  createRoutableExtension({
    name: 'MyPluginPage',
    component: () =>
      import('./components/MyPage').then(m => m.MyPage),
    mountPoint: rootRouteRef,
  }),
);

// For mountPoints - export non-routable extension
export const MyWidget = myPlugin.provide(
  createComponentExtension({
    name: 'MyWidget',
    component: {
      lazy: () => import('./components/MyWidget').then(m => m.MyWidget),
    },
  }),
);
```

## Data Fetching Patterns

Use custom hooks that consume Backstage APIs via `useApi()`:

```typescript
// hooks/useEntityCounts.ts
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import useAsync from 'react-use/lib/useAsync';

export function useEntityCounts() {
  const catalogApi = useApi(catalogApiRef);

  return useAsync(async () => {
    const [components, apis, templates] = await Promise.all([
      catalogApi.getEntities({ filter: { kind: 'Component' } }),
      catalogApi.getEntities({ filter: { kind: 'API' } }),
      catalogApi.getEntities({ filter: { kind: 'Template' } }),
    ]);
    return {
      components: components.items.length,
      apis: apis.items.length,
      templates: templates.items.length,
    };
  }, [catalogApi]);
}
```

## Styling Guidelines

Use Material UI (MUI) `makeStyles` for component styling. Match the Microsoft brand palette:

```typescript
import { makeStyles } from '@material-ui/core/styles';

const useStyles = makeStyles(theme => ({
  statCard: {
    background: theme.palette.background.paper,
    border: `1px solid ${theme.palette.divider}`,
    borderRadius: 12,
    padding: theme.spacing(3),
    textAlign: 'center',
    '&.blue': { borderTop: '3px solid #00A4EF' },
    '&.green': { borderTop: '3px solid #7FBA00' },
    '&.yellow': { borderTop: '3px solid #FFB900' },
    '&.red': { borderTop: '3px solid #F25022' },
  },
}));
```

**Color constants** (define in a shared `theme.ts`):
```typescript
export const MS_COLORS = {
  blue: '#00A4EF',
  green: '#7FBA00',
  yellow: '#FFB900',
  red: '#F25022',
  darkBlue: '#0078D4',
  sidebarBg: '#1B1B1F',
} as const;
```

## Error Handling

Wrap page components with Backstage's error boundary:

```typescript
import { ErrorBoundary } from '@backstage/core-components';

export const MyPage = () => (
  <ErrorBoundary>
    <MyPageContent />
  </ErrorBoundary>
);
```

For data fetching errors, use the `Progress` and `ResponseErrorPanel` components:

```typescript
import { Progress, ResponseErrorPanel } from '@backstage/core-components';

export const StatCards = () => {
  const { value, loading, error } = useEntityCounts();

  if (loading) return <Progress />;
  if (error) return <ResponseErrorPanel error={error} />;

  return <StatCardsView counts={value!} />;
};
```

## Testing Standards

- Unit test every component with `@testing-library/react`
- Mock Backstage APIs using `TestApiProvider`
- Test with realistic catalog data

```typescript
import { TestApiProvider } from '@backstage/test-utils';
import { catalogApiRef } from '@backstage/plugin-catalog-react';

const mockCatalogApi = {
  getEntities: jest.fn().mockResolvedValue({ items: mockEntities }),
};

render(
  <TestApiProvider apis={[[catalogApiRef, mockCatalogApi]]}>
    <StatCards />
  </TestApiProvider>
);
```

## Export as Dynamic Plugin

```bash
# In the plugin directory
npx @janus-idp/cli package export-dynamic-plugin

# This creates dist-dynamic/ with the bundle
# Then push to ACR:
oras push myacr.azurecr.io/plugins/{name}:{version} dist-dynamic/*
```

## Security Checklist

- Never hardcode secrets or API keys in plugin code
- Use `fetchApiRef` for authenticated requests (includes RHDH session token)
- Respect RBAC: check permissions before rendering admin-only components
- Sanitize any user input rendered in the UI (XSS prevention)
- Never make direct K8s API calls from frontend — use backend-for-frontend proxy
